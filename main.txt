import os
import shutil
import threading
import tkinter as tk
from tkinter import filedialog, messagebox
import difflib
import pyperclip
import ttkbootstrap as tb
from ttkbootstrap.constants import *
from datetime import datetime
from PIL import Image, ImageTk
import fitz  # PyMuPDF

# Import ttk from ttkbootstrap
from ttkbootstrap import ttk

class FolderBrowser:
    def __init__(self, root):
        self.root = root
        self.root.title("Professional File Browser")

        self.selected_files = []
        self.preview_image_label = None
        self.pdf_doc = None
        self.pdf_page_number = 0
        self.zoom_level = 1.0

        # Main frame for layout
        main_frame = tb.Frame(root)
        main_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # Directory selection frame
        dir_frame = tb.Frame(main_frame)
        dir_frame.pack(fill=tk.X, pady=(0, 10))

        self.directory_label = tb.Label(dir_frame, text="Select Directory:")
        self.directory_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.directory_entry = tb.Entry(dir_frame, width=50)
        self.directory_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        self.browse_button = tb.Button(dir_frame, text="Browse", command=self.browse_directory, bootstyle=PRIMARY)
        self.browse_button.pack(side=tk.LEFT)

        # Filename input frame
        filename_frame = tb.Frame(main_frame)
        filename_frame.pack(fill=tk.X, pady=(0, 10))

        self.file_names_label = tb.Label(filename_frame, text="Filenames (one per line):")
        self.file_names_label.pack(side=tk.LEFT, padx=(0, 10))

        self.file_names_text = tk.Text(filename_frame, width=50, height=10)
        self.file_names_text.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        button_frame = tb.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(0, 10))

        self.paste_button = tb.Button(button_frame, text="Paste from Clipboard", command=self.paste_from_clipboard, bootstyle=SUCCESS)
        self.paste_button.pack(side=tk.LEFT, padx=(0, 10))

        self.clear_button = tb.Button(button_frame, text="Clear Field", command=self.clear_field, bootstyle=DANGER)
        self.clear_button.pack(side=tk.LEFT, padx=(0, 10))

        # Options frame
        options_frame = tb.Frame(main_frame)
        options_frame.pack(fill=tk.X, pady=(0, 10))

        self.exact_match_checkbox = tb.Checkbutton(options_frame, text="Exact Match", variable=tk.BooleanVar(), bootstyle=INFO)
        self.exact_match_checkbox.pack(side=tk.LEFT, padx=(0, 10))

        self.case_sensitive_checkbox = tb.Checkbutton(options_frame, text="Case Sensitive", variable=tk.BooleanVar(), bootstyle=INFO)
        self.case_sensitive_checkbox.pack(side=tk.LEFT, padx=(0, 10))

        self.search_content_checkbox = tb.Checkbutton(options_frame, text="Search Content", variable=tk.BooleanVar(), bootstyle=INFO)
        self.search_content_checkbox.pack(side=tk.LEFT, padx=(0, 10))

        self.extension_label = tb.Label(options_frame, text="File Extension:")
        self.extension_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.extension_entry = tb.Entry(options_frame, width=10)
        self.extension_entry.pack(side=tk.LEFT, padx=(0, 10))

        self.sort_by_label = tb.Label(options_frame, text="Sort By:")
        self.sort_by_label.pack(side=tk.LEFT, padx=(0, 10))

        self.sort_by_var = tk.StringVar()
        self.sort_by_var.set("None")
        self.sort_by_combobox = ttk.Combobox(options_frame, textvariable=self.sort_by_var, values=["None", "Size", "Date"], state="readonly")
        self.sort_by_combobox.pack(side=tk.LEFT, padx=(0, 10))

        self.search_type_label = tb.Label(options_frame, text="Search Type:")
        self.search_type_label.pack(side=tk.LEFT, padx=(0, 10))

        self.search_type_var = tk.StringVar()
        self.search_type_var.set("All")
        self.search_type_combobox = ttk.Combobox(options_frame, textvariable=self.search_type_var, values=["All", "Newest", "Oldest", "Largest", "Smallest"], state="readonly")
        self.search_type_combobox.pack(side=tk.LEFT, padx=(0, 10))

        # Search button
        self.search_button = tb.Button(main_frame, text="Search", command=self.start_search_thread, bootstyle=PRIMARY)
        self.search_button.pack(fill=tk.X, pady=(0, 10))

        # Results treeview
        results_frame = tb.Frame(main_frame)
        results_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        self.results_tree = ttk.Treeview(results_frame, columns=("Filename", "Filepath", "Size", "Date Modified"), show='headings')
        self.results_tree.heading("Filename", text="Filename")
        self.results_tree.heading("Filepath", text="Filepath")
        self.results_tree.heading("Size", text="Size")
        self.results_tree.heading("Date Modified", text="Date Modified")
        self.results_tree.column("Filename", width=200, anchor=tk.W)
        self.results_tree.column("Filepath", width=400, anchor=tk.W)
        self.results_tree.column("Size", width=100, anchor=tk.W)
        self.results_tree.column("Date Modified", width=200, anchor=tk.W)
        self.results_tree.pack(fill=tk.BOTH, expand=True)

        # Allow resizing of columns
        for col in self.results_tree["columns"]:
            self.results_tree.heading(col, text=col, command=lambda _col=col: self.sort_column(self.results_tree, _col, False))

        # File operations frame
        file_ops_frame = tb.Frame(main_frame)
        file_ops_frame.pack(fill=tk.X, pady=(0, 10))

        self.copy_button = tb.Button(file_ops_frame, text="Copy Selected", command=self.copy_selected_files, bootstyle=PRIMARY)
        self.copy_button.pack(side=tk.LEFT, padx=(0, 10))
        
        self.move_button = tb.Button(file_ops_frame, text="Move Selected", command=self.move_selected_files, bootstyle=PRIMARY)
        self.move_button.pack(side=tk.LEFT, padx=(0, 10))
        
        self.delete_button = tb.Button(file_ops_frame, text="Delete Selected", command=self.delete_selected_files, bootstyle=DANGER)
        self.delete_button.pack(side=tk.LEFT, padx=(0, 10))

        # Status and progress bar frame
        status_frame = tb.Frame(main_frame)
        status_frame.pack(fill=tk.X, pady=(0, 10))

        self.status_label = tb.Label(status_frame, text="Status: Ready")
        self.status_label.pack(side=tk.LEFT, padx=(0, 10))

        self.progress_bar = tb.Progressbar(status_frame, orient=tk.HORIZONTAL, length=400, mode='determinate')
        self.progress_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        # File preview frame
        preview_frame = tb.Frame(main_frame)
        preview_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        self.preview_label = tb.Label(preview_frame, text="File Preview:")
        self.preview_label.pack(side=tk.TOP, anchor=tk.W, padx=(0, 10))

        # Canvas and scrollbar for PDF preview
        self.canvas_frame = tb.Frame(preview_frame)
        self.canvas_frame.pack(fill=tk.BOTH, expand=True)

        self.canvas = tk.Canvas(self.canvas_frame, bg="white")
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.scrollbar = tb.Scrollbar(self.canvas_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        # Enable mouse wheel scrolling
        self.canvas.bind_all("<MouseWheel>", self.on_mouse_wheel)

        # PDF navigation and zoom controls
        pdf_nav_frame = tb.Frame(preview_frame)
        pdf_nav_frame.pack(pady=(10, 0))

        self.prev_page_button = tb.Button(pdf_nav_frame, text="Previous Page", command=self.prev_pdf_page, state=tk.DISABLED)
        self.prev_page_button.pack(side=tk.LEFT, padx=5)

        self.next_page_button = tb.Button(pdf_nav_frame, text="Next Page", command=self.next_pdf_page, state=tk.DISABLED)
        self.next_page_button.pack(side=tk.LEFT, padx=5)

        self.zoom_in_button = tb.Button(pdf_nav_frame, text="Zoom In", command=self.zoom_in_pdf, state=tk.DISABLED)
        self.zoom_in_button.pack(side=tk.LEFT, padx=5)

        self.zoom_out_button = tb.Button(pdf_nav_frame, text="Zoom Out", command=self.zoom_out_pdf, state=tk.DISABLED)
        self.zoom_out_button.pack(side=tk.LEFT, padx=5)

        self.results_tree.bind('<<TreeviewSelect>>', self.preview_file)

        # Text preview widget
        self.preview_text = tk.Text(preview_frame, wrap="word", state=tk.DISABLED)
        self.preview_text.pack(fill=tk.BOTH, expand=True)

    def browse_directory(self):
        directory = filedialog.askdirectory()
        if directory:
            self.directory_entry.delete(0, tk.END)
            self.directory_entry.insert(0, directory)

    def paste_from_clipboard(self):
        clipboard_content = pyperclip.paste()
        self.file_names_text.insert(tk.END, clipboard_content)

    def clear_field(self):
        self.file_names_text.delete("1.0", tk.END)

    def start_search_thread(self):
        self.search_button.config(state=tk.DISABLED)
        self.status_label.config(text="Status: Searching...")
        self.progress_bar.start()
        search_thread = threading.Thread(target=self.search_files)
        search_thread.start()

    def search_files(self):
        directory = self.directory_entry.get()
        exact_match = self.exact_match_checkbox.instate(['selected'])
        case_sensitive = self.case_sensitive_checkbox.instate(['selected'])
        search_content = self.search_content_checkbox.instate(['selected'])
        extension_filter = self.extension_entry.get().strip()

        filenames = self.file_names_text.get("1.0", tk.END).strip().split('\n')

        if not directory:
            messagebox.showerror("Error", "Please select a directory")
            self.update_status("Status: Ready")
            self.search_button.config(state=tk.NORMAL)
            self.progress_bar.stop()
            return

        if not filenames:
            messagebox.showerror("Error", "Please enter filenames")
            self.update_status("Status: Ready")
            self.search_button.config(state=tk.NORMAL)
            self.progress_bar.stop()
            return

        self.results_tree.delete(*self.results_tree.get_children())
        self.selected_files = []

        file_paths = []
        for root, _, files in os.walk(directory):
            for file in files:
                file_name, file_extension = os.path.splitext(file)
                if extension_filter and file_extension != extension_filter:
                    continue
                for target in filenames:
                    target_name, target_extension = os.path.splitext(target)
                    if exact_match:
                        if case_sensitive:
                            if file == target or file_name == target_name:
                                file_path = os.path.join(root, file)
                                file_paths.append(file_path)
                        else:
                            if file.lower() == target.lower() or file_name.lower() == target_name.lower():
                                file_path = os.path.join(root, file)
                                file_paths.append(file_path)
                    else:
                        if search_content:
                            if self.search_file_content(os.path.join(root, file), target):
                                file_path = os.path.join(root, file)
                                file_paths.append(file_path)
                        else:
                            if difflib.SequenceMatcher(None, file_name.lower() if not case_sensitive else file_name, target_name.lower() if not case_sensitive else target_name).ratio() > 0.8:
                                file_path = os.path.join(root, file)
                                file_paths.append(file_path)

        total_files = len(file_paths)
        if total_files == 0:
            self.update_status("Status: No files found")
            self.search_button.config(state=tk.NORMAL)
            self.progress_bar.stop()
            return

        sort_by = self.sort_by_var.get()
        if sort_by == "Size":
            file_paths.sort(key=lambda x: os.path.getsize(x))
        elif sort_by == "Date":
            file_paths.sort(key=lambda x: os.path.getmtime(x))

        search_type = self.search_type_var.get()
        if search_type == "Newest":
            file_paths = [max(file_paths, key=os.path.getmtime)]
        elif search_type == "Oldest":
            file_paths = [min(file_paths, key=os.path.getmtime)]
        elif search_type == "Largest":
            file_paths = [max(file_paths, key=os.path.getsize)]
        elif search_type == "Smallest":
            file_paths = [min(file_paths, key=os.path.getsize)]

        processed_files = 0
        for file_path in file_paths:
            processed_files += 1
            self.update_progress(processed_files, total_files)
            size = self.format_size(os.path.getsize(file_path))
            date_modified = datetime.fromtimestamp(os.path.getmtime(file_path)).strftime('%Y-%m-%d %H:%M:%S')
            self.results_tree.insert('', 'end', values=(os.path.basename(file_path), file_path, size, date_modified))

        self.update_status("Status: Search Complete")
        self.search_button.config(state=tk.NORMAL)
        self.progress_bar.stop()

    def search_file_content(self, file_path, search_text):
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
                return search_text in content
        except:
            return False

    def update_progress(self, current, total):
        progress = int((current / total) * 100)
        self.progress_bar['value'] = progress
        self.root.update_idletasks()

    def update_status(self, status):
        self.status_label.config(text=status)

    def copy_selected_files(self):
        self.perform_file_operation(self.copy_file)

    def move_selected_files(self):
        self.perform_file_operation(self.move_file)

    def delete_selected_files(self):
        self.perform_file_operation(self.delete_file)

    def perform_file_operation(self, operation):
        selected_items = self.results_tree.selection()
        if not selected_items:
            messagebox.showerror("Error", "No files selected")
            return

        if operation in [self.copy_file, self.move_file]:
            destination = filedialog.askdirectory()
            if not destination:
                return

        for item in selected_items:
            file_path = self.results_tree.item(item, 'values')[1]
            if operation == self.delete_file:
                operation(file_path)
            else:
                operation(file_path, destination)

        messagebox.showinfo("Success", "Operation completed successfully")

    def copy_file(self, file_path, destination):
        base_name = os.path.basename(file_path)
        destination_path = os.path.join(destination, base_name)

        if os.path.exists(destination_path):
            creation_time = os.path.getctime(file_path)
            creation_date = datetime.fromtimestamp(creation_time).strftime('%Y%m%d_%H%M%S')
            base_name, extension = os.path.splitext(base_name)
            destination_path = os.path.join(destination, f"{base_name}_{creation_date}{extension}")
            
            counter = 1
            while os.path.exists(destination_path):
                destination_path = os.path.join(destination, f"{base_name}_{creation_date}_{counter}{extension}")
                counter += 1

        shutil.copy(file_path, destination_path)

    def move_file(self, file_path, destination):
        base_name = os.path.basename(file_path)
        destination_path = os.path.join(destination, base_name)

        if os.path.exists(destination_path):
            creation_time = os.path.getctime(file_path)
            creation_date = datetime.fromtimestamp(creation_time).strftime('%Y%m%d_%H%M%S')
            base_name, extension = os.path.splitext(base_name)
            destination_path = os.path.join(destination, f"{base_name}_{creation_date}{extension}")
            
            counter = 1
            while os.path.exists(destination_path):
                destination_path = os.path.join(destination, f"{base_name}_{creation_date}_{counter}{extension}")
                counter += 1

        shutil.move(file_path, destination_path)

    def delete_file(self, file_path):
        os.remove(file_path)

    def preview_file(self, event):
        selected_items = self.results_tree.selection()
        if selected_items:
            file_path = self.results_tree.item(selected_items[0], 'values')[1]
            file_extension = os.path.splitext(file_path)[1].lower()
            
            # Clear the canvas and reset PDF variables
            self.canvas.delete("all")
            self.pdf_doc = None
            self.pdf_page_number = 0
            self.zoom_level = 1.0

            if file_extension in ['.txt', '.py', '.log', '.md']:
                self.preview_text.config(state=tk.NORMAL)
                self.preview_text.delete("1.0", tk.END)
                self.preview_text.pack(fill=tk.BOTH, expand=True)  # Show the text widget
                try:
                    with open(file_path, 'r', encoding='utf-8') as file:
                        content = file.read()
                    self.preview_text.insert(tk.END, content)
                except Exception as e:
                    self.preview_text.insert(tk.END, f"Error reading file: {e}")
                self.preview_text.config(state=tk.DISABLED)
            elif file_extension in ['.png', '.jpg', '.jpeg', '.gif', '.bmp']:
                self.preview_text.pack_forget()  # Hide the text widget
                try:
                    img = Image.open(file_path)
                    self.display_image_on_canvas(img)
                except Exception as e:
                    self.preview_text.config(state=tk.NORMAL)
                    self.preview_text.delete("1.0", tk.END)
                    self.preview_text.insert(tk.END, f"Error displaying image: {e}")
                    self.preview_text.pack(fill=tk.BOTH, expand=True)  # Show the text widget
                    self.preview_text.config(state=tk.DISABLED)
            elif file_extension in ['.pdf']:
                self.preview_text.pack_forget()  # Hide the text widget
                try:
                    self.load_pdf(file_path)
                    self.show_pdf_page(0)
                except Exception as e:
                    self.preview_text.config(state=tk.NORMAL)
                    self.preview_text.delete("1.0", tk.END)
                    self.preview_text.insert(tk.END, f"Error displaying PDF: {e}")
                    self.preview_text.pack(fill=tk.BOTH, expand=True)  # Show the text widget
                    self.preview_text.config(state=tk.DISABLED)
            else:
                self.preview_text.config(state=tk.NORMAL)
                self.preview_text.delete("1.0", tk.END)
                self.preview_text.insert(tk.END, "No preview available for this file type.")
                self.preview_text.pack(fill=tk.BOTH, expand=True)  # Show the text widget
                self.preview_text.config(state=tk.DISABLED)

    def load_pdf(self, file_path):
        self.pdf_doc = fitz.open(file_path)
        self.pdf_page_number = 0
        self.zoom_level = 1.0
        self.update_pdf_navigation_buttons()

    def show_pdf_page(self, page_number):
        if self.pdf_doc:
            page = self.pdf_doc.load_page(page_number)
            zoom_matrix = fitz.Matrix(self.zoom_level, self.zoom_level)
            pix = page.get_pixmap(matrix=zoom_matrix)
            img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)

            self.canvas.config(scrollregion=self.canvas.bbox(tk.ALL))
            self.display_image_on_canvas(img)

            self.update_pdf_navigation_buttons()

    def display_image_on_canvas(self, img):
        self.canvas_img = ImageTk.PhotoImage(img)
        self.canvas.create_image(self.canvas.winfo_width()//2, self.canvas.winfo_height()//2, anchor=tk.CENTER, image=self.canvas_img)
        self.canvas.config(scrollregion=self.canvas.bbox(tk.ALL))

    def prev_pdf_page(self):
        if self.pdf_doc and self.pdf_page_number > 0:
            self.pdf_page_number -= 1
            self.show_pdf_page(self.pdf_page_number)

    def next_pdf_page(self):
        if self.pdf_doc and self.pdf_page_number < len(self.pdf_doc) - 1:
            self.pdf_page_number += 1
            self.show_pdf_page(self.pdf_page_number)

    def zoom_in_pdf(self):
        if self.pdf_doc:
            self.zoom_level += 0.1
            self.show_pdf_page(self.pdf_page_number)

    def zoom_out_pdf(self):
        if self.pdf_doc and self.zoom_level > 0.1:
            self.zoom_level -= 0.1
            self.show_pdf_page(self.pdf_page_number)

    def update_pdf_navigation_buttons(self):
        if self.pdf_doc:
            self.prev_page_button.config(state=tk.NORMAL if self.pdf_page_number > 0 else tk.DISABLED)
            self.next_page_button.config(state=tk.NORMAL if self.pdf_page_number < len(self.pdf_doc) - 1 else tk.DISABLED)
            self.zoom_in_button.config(state=tk.NORMAL)
            self.zoom_out_button.config(state=tk.NORMAL)
        else:
            self.prev_page_button.config(state=tk.DISABLED)
            self.next_page_button.config(state=tk.DISABLED)
            self.zoom_in_button.config(state=tk.DISABLED)
            self.zoom_out_button.config(state=tk.DISABLED)

    def on_mouse_wheel(self, event):
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

    def sort_column(self, tv, col, reverse):
        l = [(tv.set(k, col), k) for k in tv.get_children('')]
        try:
            l.sort(key=lambda t: float(t[0]), reverse=reverse)
        except ValueError:
            l.sort(reverse=reverse)

        for index, (val, k) in enumerate(l):
            tv.move(k, '', index)

        tv.heading(col, command=lambda: self.sort_column(tv, col, not reverse))

    def format_size(self, size):
        # Convert size to KB, MB, GB, etc.
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024:
                return f"{size:.2f} {unit}"
            size /= 1024

if __name__ == "__main__":
    root = tb.Window(themename="flatly")
    app = FolderBrowser(root)
    root.mainloop()
